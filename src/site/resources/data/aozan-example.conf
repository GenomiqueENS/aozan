#
# HiSeq
#

# You can include here another configuration file. This useful in a multiserver context
# The include directive must be the first entry of the file (except comments)
#include=path_to_the_other_configuration_file

# Enable or disable Aozan
aozan.enable=True

# Mode debug
aozan.debug=False

#
# Mail configuration
#

# Enable email sending
send.mail=True

# SMTP server name
smtp.server=smtp.example.com

# SMTP server port
#smtp.port=25

# Use StartTLS to connect to the SMTP server
#smtp.use.starttls=False

# Use SSL to connect to the SMTP server
#smtp.use.ssl=False

# Login to use for the connection to the SMTP server
#smtp.login=yourlogin

# Password to use for the connection to the SMTP server
#smtp.password=yourpassword


# From field of email
mail.from=aozan@example.com

# To field of email
mail.to=me@example.com

# Email recipient when an error occurs during Aozan (Optional)
mail.error.to=aozan-errors@example.com

#
# Data paths
#

# Aozan configuration files directory
aozan.var.path=/path/to/aozan/data

# Aozan log file
aozan.log.path=/var/log/aozan.log

# Paths where HiSeq write data, two path separated by ':'
hiseq.data.path=/path/to/hiseq/output

# Where store bcl files
bcl.data.path=/path/to/bcl

# Where store fastq files
fastq.data.path=/path/to/fastq

# Were store runs informations and qc data
reports.data.path=/path/to/runs

# Where store Bcl2fastq samplesheet files in XLS or CSV format
bcl2fastq.samplesheet.path=/path/to/samplesheets

# Prefix for the Bcl2fastq samplesheet files
bcl2fastq.samplesheet.prefix.filename=samplesheet

# File that contains alias for barcodes
index.sequences=/path/to/aozan/resources/indexes-sequences.txt

# Temporary directory
tmp.path=/tmp

# Uncomment to enable the use a custom index.html template.
#index.html.template=/path/to/template

# Uncomment to enable links to a website in emails
#reports.url=http://XXXXXX/runs

# Read only output files
read.only.output.files=True

# Lock file path
aozan.lock.file=/var/lock/aozan.lock

# Log level
#aozan.log.level=ALL

#
# First base report step
#

# Enable the first base report step
first.base.report.step=True


#
# Synchronization step
#

# Enable the synchronization step
sync.step=True

# Parameter synchronization

# Enable continious synchronization
sync.continuous.sync=True

# Age in minutes of the files to synchronized when using continious synchronization
sync.continuous.sync.min.age.files=15


#
# Demux step
#

# Enable demultiplexing step
demux.step=True

# Use the output the sequencers as input of bcl2fastq instead of the content of the synchronization directory
#demux.use.hiseq.output=True

# Bcl2fastq 2 executable path
bcl2fastq.path=/usr/local/bcl2fastq

# Use Docker for bcl2fastq 2
demux.use.docker.enable=False

# Mismatches to allow
bcl2fastq.mismatches=0

# Thread to use
#bcl2fastq.threads=4

# Enable Bcl2fastq samplesheets archiving
demux.archive.samplesheets=True


#
# Recompress step
#

# Enable recompress step
recompress.step=True

# Delete fastq files when successfully recompressed a file
recompress.delete.original.fastq.files=True

# recompression level used for recompressor
#recompress.compression.level=9

# Compression type program
#recompress.compression=bzip2

# Thread to use
#recompress.threads=4


#
# Quality Control
#

# Enable QC step
qc.step=True

# Read readX.xml files generated by old versions of HCS instead of using InterOp files
#qc.conf.read.xml.collector.used=False

# Number of threads to use
#qc.conf.threads=4

# Save QC raw data
qc.report.save.raw.data=True

# Save QC XML file
qc.report.save.report.data=True

# Custom stylesheet to use to create the Aozan QC report
#qc.report.stylesheet=/path/to/aozan/resources/qc-stylesheet.xsl



#
# Global QC tests
#


# Raw clusters global tests

qc.test.global.raw.cluster.count.enable=True
#qc.test.global.raw.cluster.count.interval=[0, 1]

qc.test.global.mean.raw.cluster.count.enable=True
#qc.test.global.mean.raw.cluster.count.interval=[0, 1]

qc.test.global.median.raw.cluster.count.enable=True
#qc.test.global.median.raw.cluster.count.interval=[0, 1]

qc.test.global.raw.cluster.sd.enable=True
#qc.test.global.raw.cluster.sd.interval=[0, 1]

qc.test.global.cluster.density.enable=True
#qc.test.global.cluster.density.interval=[0, 1]

qc.test.global.cluster.density.pf.enable=True
#qc.test.global.cluster.density.pf.interval=[0, 1]


# Passing filter clusters global tests

qc.test.global.pf.cluster.percent.enable=True
qc.test.global.pf.cluster.percent.interval=[0.8, 1]

qc.test.global.pf.cluster.count.enable=True
#qc.test.global.pf.cluster.count.interval=[0, 1]

qc.test.global.mean.pf.cluster.count.enable=True
#qc.test.global.mean.pf.cluster.count.interval=[0, 1]

qc.test.global.median.pf.cluster.count.enable=True
#qc.test.global.median.pf.cluster.count.interval=[0, 1]

qc.test.global.pf.cluster.sd.enable=True
#qc.test.global.pf.cluster.sd.interval=[0, 1]


# PhiX global tests

qc.test.global.phix.align.percent.enable=True
qc.test.global.phix.align.percent.interval=[0.0, 0.25]

qc.test.global.phix.raw.cluster.count.enable=True
#qc.test.global.phix.raw.cluster.count.interval=[0, 1]

qc.test.global.mean.phix.raw.cluster.count.enable=True
#qc.test.global.mean.phix.raw.cluster.count.interval=[0, 1]

qc.test.global.median.phix.raw.cluster.count.enable=True
#qc.test.global.median.phix.raw.cluster.count.interval=[0, 1]

qc.test.global.phix.raw.cluster.sd.enable=True
#qc.test.global.phix.raw.cluster.sd.interval=[0, 1]


# Quality global tests

qc.test.global.q30.percent.enable=True
#qc.test.global.q30.percent.interval=[0, 1]

qc.test.global.error.rate.enable=True
#qc.test.global.error.rate.interval=[0, 1]


# Other global tests

qc.test.global.undetermined.cluster.percent.enable=True
#qc.test.global.undetermined.cluster.percent.interval=[0, 1]

qc.test.global.base.count.enable=True
#qc.test.global.base.count.interval=[0, 1]

qc.test.global.non.indexed.base.count.enable=True
#qc.test.global.non.indexed.base.count.interval=[0, 1]

qc.test.global.cycle.count.enable=True
#qc.test.global.cycle.count.interval=[0, 1]

qc.test.global.lane.count.enable=True
#qc.test.global.lane.count.interval=[0, 1]

qc.test.global.sample.count.enable=True
#qc.test.global.sample.count.interval=[0, 1]

qc.test.global.project.count.enable=True
#qc.test.global.project.count.interval=[0, 1]

qc.test.global.occupancy.percent.enable=True
#qc.test.global.occupancy.percent.interval=[0, 1]

qc.test.global.loading.concentration.percent.enable=True
#qc.test.global.loading.concentration.interval=[0, 1]

#
# Lane QC tests
#


# Clusters lane tests

qc.test.lane.cluster.density.enable=True
#qc.test.lane.cluster.density.interval=[0, 1]

qc.test.lane.yield.enable=True
#qc.test.lane.yield.interval=[0, 1]

qc.test.lane.yield.pf.enable=True
#qc.test.lane.yield.pf.interval=[0, 1]

qc.test.lane.raw.cluster.count.enable=True
#qc.test.lane.raw.cluster.count.interval=[0, 1]

qc.test.lane.pf.cluster.count.enable=True
#qc.test.lane.pf.cluster.count.interval=[0, 1]

qc.test.lane.pf.cluster.percent.enable=True
qc.test.lane.pf.cluster.percent.interval=[0.6, 1]

qc.test.lane.cluster.density.enable=True
#qc.test.lane.cluster.density.interval=[0, 1]

qc.test.lane.cluster.density.pf.enable=True
#qc.test.lane.cluster.density.pf.interval=[0, 1]


# PhiX lane tests

qc.test.lane.phix.align.percent.enable=True
qc.test.lane.phix.align.percent.interval=[0.75, 1.0]

qc.test.lane.phix.raw.cluster.count.enable=True
#qc.test.lane.phix.raw.cluster.count.interval=[0, 1]


# Quality lane tests

qc.test.lane.q30.percent.enable=True
#qc.test.lane.q30.percent.interval=[0, 1]

qc.test.lane.error.rate.enable=True
#qc.test.lane.error.rate.interval=[0, 1]

qc.test.lane.35.cycle.error.rate.enable=True
qc.test.lane.35.cycle.error.rate.interval=[0, 0.01]

qc.test.lane.75.cycle.error.rate.enable=True
qc.test.lane.75.cycle.error.rate.interval=[0, 0.015]

qc.test.lane.100.cycle.error.rate.enable=True
qc.test.lane.100.cycle.error.rate.interval=[0, 0.02]

qc.test.lane.first.cycle.intensity.enable=True
#qc.test.lane.first.cycle.intensity.interval=[0, 1]

qc.test.lane.cycle.20.intensity.percent.enable=True
qc.test.lane.cycle.20.intensity.percent.interval=[0.5, ]

qc.test.lane.phasing.prephasing.percent.enable=True
qc.test.lane.phasing.prephasing.percent.phasing.interval=[0, 0.004]
qc.test.lane.phasing.prephasing.percent.prephasing.interval=[0, 0.005]

qc.test.lane.occupancy.percent.enable=True
#qc.test.lane.occupancy.percent.interval=[0,1]


#
# Project tests
#


# Raw clusters project tests

qc.test.project.raw.cluster.count.enable=True
#qc.test.project.raw.cluster.count.interval=[0, 1]

qc.test.project.min.raw.cluster.count.enable=True
#qc.test.project.min.raw.cluster.count.interval=[0, 1]

qc.test.project.max.raw.cluster.count.enable=True
#qc.test.project.max.raw.cluster.count.interval=[0, 1]

qc.test.project.recoverable.raw.cluster.percent.enable=True
#qc.test.project.recoverable.raw.cluster.percent.interval=[0, 1]


# Passing filter clusters project tests

qc.test.project.pf.cluster.count.enable=True
#qc.test.project.pf.cluster.count.interval=[0, 1]

qc.test.project.min.pf.cluster.count.enable=True
#qc.test.project.min.pf.cluster.count.interval=[0, 1]

qc.test.project.max.pf.cluster.count.enable=True
#qc.test.project.max.pf.cluster.count.interval=[0, 1]

qc.test.project.recoverable.pf.cluster.percent.enable=True
#qc.test.project.recoverable.pf.cluster.percent.interval=[0, 1]


# General project tests

qc.test.project.is.indexed.enable=True
#qc.test.project.is.indexed.interval=[0, 1]


# FastQ Screen project tests

qc.test.project.fastqscreen.sample.overcontamination.count.enable=True
#qc.test.project.fastqscreen.sample.overcontamination.count.interval=[0, 1]

qc.test.project.fastqscreen.report.enable=True
#qc.test.project.fastqscreen.report.interval=[0, 1]


# MutiQC project tests

qc.test.project.multiqc.report.enable=True
#qc.conf.multiqc.docker.image=ewels/multiqc:v1.11
#qc.conf.multiqc.docker.executable=


# Bcl2fastq report related sample tests

qc.test.project.sample.count.enable=True
#qc.test.project.sample.count.interval=[0, 1]

qc.test.project.genome.names.enable=True
#qc.test.project.genome.names.interval=[0, 1]

qc.test.project.lane.count.enable=True
#qc.test.project.lane.count.interval=[0, 1]


#
# Sample tests
#

qc.test.sample.genome.names.enable=True

# Recoverable clusters sample tests

qc.test.sample.raw.cluster.count.enable=True
#qc.test.sample.raw.cluster.count.interval=[0, 1]

qc.test.sample.pf.percent.enable=True
qc.test.sample.pf.percent.interval=[0.6, 1.0]

qc.test.sample.pf.cluster.count.enable=True
qc.test.sample.pf.cluster.count.interval=[32500000, ]

qc.test.sample.base.pf.mean.quality.score.enable=True
#qc.test.sample.base.pf.mean.quality.score.interval=[0, 1]

qc.test.sample.q30.percent.enable=True
qc.test.sample.q30.percent.interval=[0.75, 1.0]

qc.test.sample.in.lane.percent.enable=True
#qc.test.sample.in.lane.percent.interval=[0, 1]

qc.test.sample.recoverable.raw.cluster.count.enable=True
qc.test.sample.recoverable.raw.cluster.count.interval=[1200000000,]

qc.test.sample.recoverable.pf.cluster.count.enable=True
qc.test.sample.recoverable.pf.cluster.count.interval=[1000000000,]

qc.test.sample.cluster.recovery.report.enable=True
#qc.test.sample.cluster.recovery.report.interval=[0, 1]


# FastQC sample sample tests

qc.test.sample.fastqc.basic.stats.enable=True
#qc.test.sample.fastqc.basic.stats.interval=[0, 1]

qc.test.sample.fastqc.per.base.quality.scores.enable=True
#qc.test.sample.fastqc.per.base.quality.scores.interval=[0, 1]

qc.test.sample.fastqc.per.tile.sequence.quality.enable=True
#qc.test.sample.fastqc.per.tile.sequence.quality.interval=[0, 1]

qc.test.sample.fastqc.per.sequence.quality.scores.enable=True
#qc.test.sample.fastqc.per.sequence.quality.scores.interval=[0, 1]

qc.test.sample.fastqc.per.base.sequence.content.enable=True
#qc.test.sample.fastqc.per.base.sequence.content.interval=[0, 1]

qc.test.sample.fastqc.per.sequence.gc.content.enable=True
#qc.test.sample.fastqc.per.sequence.gc.content.interval=[0, 1]

qc.test.sample.fastqc.n.content.enable=True
#qc.test.sample.fastqc.n.content.interval=[0, 1]

qc.test.sample.fastqc.sequence.length.distribution.enable=True
#qc.test.sample.fastqc.sequence.length.distribution.interval=[0, 1]

qc.test.sample.fastqc.duplication.level.enable=True
#qc.test.sample.fastqc.duplication.level.interval=[0, 1]

qc.test.sample.fastqc.overrepresented.sequences.enable=True
#qc.test.sample.fastqc.overrepresented.sequences.interval=[0, 1]

qc.test.sample.fastqc.adapter.content.enable=True
#qc.test.sample.fastqc.adapter.content.interval=[0, 1]

qc.test.sample.fastqc.kmer.content.enable=True
#qc.test.sample.fastqc.kmer.content.interval=[0, 1]


# FastQ Screen sample tests

qc.test.sample.fastqscreen.mapped.percent.enable=True
qc.test.sample.fastqscreen.mapped.percent.interval=[0, 0.1]

qc.test.sample.fastqscreen.mapped.except.ref.genome.percent.enable=True
qc.test.sample.fastqscreen.mapped.except.ref.genome.percent.interval=[0, 0.1]

qc.test.sample.fastqscreen.report.enable=True
#qc.test.sample.fastqscreen.report.interval=[0, 1]


#
# Pooled sample tests
#


# Raw clusters pooled sample tests

qc.test.pooledsample.sample.count.enable=True
#qc.test.pooledsample.sample.count.interval=[0, 1]

qc.test.pooledsample.raw.cluster.count.enable=True
qc.test.pooledsample.raw.cluster.count.interval=[200000000,]

qc.test.pooledsample.min.raw.cluster.count.enable=True
#qc.test.pooledsample.min.raw.cluster.count.interval=[0, 1]

qc.test.pooledsample.max.raw.cluster.count.enable=True
#qc.test.pooledsample.max.raw.cluster.count.interval=[0, 1]

qc.test.pooledsample.raw.cluster.recovery.count.enable=True
#qc.test.pooledsample.raw.cluster.recovery.count.interval=[0, 1]

qc.test.pooledsample.recoverable.raw.cluster.percent.enable=True
#qc.test.pooledsample.recoverable.raw.cluster.percent.interval=[0, 1]


# Passing filter clusters pooled sample tests

qc.test.pooledsample.pf.percent.enable=True
#qc.test.pooledsample.pf.percent.interval=[0, 1]

qc.test.pooledsample.pf.cluster.count.enable=True
qc.test.pooledsample.pf.cluster.count.interval=[130000000, ]

qc.test.pooledsample.min.pf.cluster.count.enable=True
#qc.test.pooledsample.min.pf.cluster.count.interval=[0, 1]

qc.test.pooledsample.max.pf.cluster.count.enable=True
#qc.test.pooledsample.max.pf.cluster.count.interval=[0, 1]

qc.test.pooledsample.pf.cluster.recovery.count.enable=True
#qc.test.pooledsample.pf.cluster.recovery.count.interval=[0, 1]

qc.test.pooledsample.recoverable.pf.cluster.percent.enable=True
#qc.test.pooledsample.recoverable.pf.cluster.percent.interval=[0, 1]


# General & Quality pooled sample tests

qc.test.pooledsample.q30.percent.enable=True
#qc.test.pooledsample.q30.percent.interval=[0, 1]

qc.test.pooledsample.in.run.percent.enable=True
#qc.test.pooledsample.in.run.percent.interval=[0, 1]

qc.test.pooledsample.in.project.percent.enable=True
#qc.test.pooledsample.in.project.percent.interval=[0, 1]

qc.test.pooledsample.sample.in.pool.count.enable=True
#qc.test.pooledsample.sample.in.pool.count.interval=[0, 1]

qc.test.pooledsample.genome.names.enable=True
#qc.test.pooledsample.genome.names.interval=[0, 1]


# FastQ Screen pooled sample tests

qc.test.pooledsample.fastqscreen.sample.overcontamination.count.enable=True
#qc.test.pooledsample.fastqscreen.sample.overcontamination.count.interval=[0, 1]

qc.test.pooledsample.fastqscreen.report.enable=True
#qc.test.pooledsample.fastqscreen.report.interval=[0, 1]

qc.test.pooledsample.fastqscreen.mapped.percent.enable=True
qc.test.pooledsample.fastqscreen.mapped.percent.interval=[0, 0.1]

qc.test.pooledsample.fastqscreen.mapped.except.ref.percent.enable=True
qc.test.pooledsample.fastqscreen.mapped.except.ref.percent.interval=[0, 0.1]

qc.test.pooledsample.fastqscreen.report.enable=True
#qc.test.pooledsample.fastqscreen.report.interval=[0, 1]


#
# Undetermined cluster recovery configuration
#

# Custom stylesheet to use to create the undetermined recovery cluster report
#qc.conf.undetermined.indexed.xsl.file=/path/to/aozan/resources/recovery-clusters-stylesheet.xsl


#
# FastQC configuration
#

# Path to a specific contaminants list, to replace the default list provided by FastQC
#qc.conf.fastqc.contaminant.file=/path/to/aozan/resources/contaminants_fastqc.txt

# Define kmer-size, default value: 5
qc.conf.fastqc.kmer.size=5

# Disable grouping of bases for reads > 50bp. Default value : False
qc.conf.fastqc.nogroup=False

# Path to a specific adapter file, replace default file
#qc.conf.fastqc.adapter.file=/path/to/aozan/resources/adapters.txt

# Path to a specific limits file, replace default file
#qc.conf.fastqc.limits.file=/path/to/aozan/resources/limits_modules.txt

# Use exponential base groups in graph
qc.conf.fastqc.expgroup=False

# Illumina FASTQ format
qc.conf.fastqc.casava=False

# Option for filter Illumina FASTQ files
qc.conf.fastqc.nofilter=False

# Run FastQC on undetermined indices samples
qc.conf.fastqc.process.undetermined.samples=True

# Enable Blast for unknown sequences in OverepresentedSeq
qc.conf.fastqc.blast.enable=False

# Use Docker to launch Blast
qc.conf.fastqc.blast.use.docker=False

# Blast executable path, blastall (Blast2) or blastn (Blast+)
qc.conf.fastqc.blast.path=/usr/bin/blastall

# Path to the database nt, access to nt.pal file
qc.conf.fastqc.blast.db.path=/path/to/ncbi_database_nt

# Optional Blast parameters (excepted parameters: -d, -p, -m (only possible with XML), -a)
qc.conf.fastqc.blast.arguments=


#
# Fastqscreen configuration
#

# Run FastqScreen on undetermined indices samples on all genomes available for the run
qc.conf.fastqscreen.process.undetermined.samples=True

# Path to the file which make the correspondence between genome name in bcl2fastq samplesheet and the reference genome name
qc.conf.fastqscreen.genome.aliases.path=/path/to/aozan/resources/alias_name_genome_fastqscreen.txt

# Path to the genomes descriptions repository
qc.conf.fastqscreen.genome.descs.path=/path/to/aozan/resources/genomes_descs

# Path to the genomes repository
qc.conf.fastqscreen.genomes.path=/path/to/aozan/resources/genomes

# Path to the genomes indexes repository
qc.conf.fastqscreen.mapper.indexes.path=/path/to/aozan/resources/mappers_indexes

# List of reference genomes
qc.conf.fastqscreen.genomes=phix,adapters

# Enable contamination search in control lane
qc.conf.fastqscreen.mapping.skip.control.lane=True

# For paired-end runs, only align the first read FASTQ file
qc.conf.fastqscreen.mapping.ignore.paired.end.mode=True

# The maximum number of reads to use with FastQ Screen
qc.conf.fastqscreen.fastq.max.reads.parsed=200000

# Use only the first X PF reads in the FASTQ files to create the subset of read to use by FastQ Screen
qc.conf.fastqscreen.fastq.reads.pf.used=30000000

# Maximun read length (full length if value is < 0)
qc.conf.fastqscreen.max.read.length=75

# Custom stylesheet to use to create the HTML fastqscreen report for samples
#qc.conf.fastqscreen.xsl.file=/path/to/aozan/resources/fastqscreen-samples-stylesheet.xsl

# Custom stylesheet to use to create the HTML fastqscreen report for projects
#qc.conf.fastqscreen.project.xsl.file=/path/to/aozan/resources/fastqscreen-project-stylesheet.xsl

# Threshold of contamination for projects
#qc.conf.fastqscreen.project.contamination.percent.threshold=0.10

# Mapper to use for FastQ Screen
qc.conf.fastqscreen.mapper=bowtie

# Optional arguments of FastQ Screen
qc.conf.fastqscreen.mapper.arguments=-l 20 -k 2 --chunkmbs 512


#
# MultiQC configuration
#

# Use Docker to launch MultiQC
qc.conf.multiqc.use.docker=True
