package fr.ens.biologie.genomique.aozan.collectors;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import fr.ens.biologie.genomique.aozan.AozanException;
import fr.ens.biologie.genomique.aozan.QC;
import fr.ens.biologie.genomique.aozan.RunData;
import fr.ens.biologie.genomique.aozan.util.CSVLineParser;
import fr.ens.biologie.genomique.aozan.util.CVSParser;

/**
 * This collector parse Demultiplex_Stats.csv file generated by bcl-convert.
 * @author Laurent Jourdren
 * @since 3.0
 */
public class DemultiplexStatsCollector extends DemultiplexingCollector {

  /** The Constant ALL_NAME_KEY. */
  private static final String ALL_NAME_KEY = "all";

  /** The Constant UNDETERMINED_NAME_KEY. */
  private static final String UNDETERMINED_NAME_KEY = "Undetermined";

  /** The Bcl2fastq output path. */
  private String bcl2FastqOutputPath;

  /**
   * This class define an entry of the CVS file.
   */
  private static class Entry {

    private final int lane;
    private final String sampleID;
    private final String index;
    private final int readCount;
    private final int perfectIndexReadCount;
    private final int oneMismatchIndexReadCount;
    private final long q30BaseCount;
    private final double meanPFQualityScore;

    /**
     * Compute quality score sum.
     * @param readSize the read size
     * @return the quality score sum
     */
    private long qualityScoreSum(int readSize) {
      return (long) (((long) readCount * readSize) * meanPFQualityScore);
    }

    /**
     * Compute the yiedl.
     * @param readSize the read size
     * @return the yield
     */
    private long yield(int readSize) {

      return ((long) this.readCount) * readSize;
    }

    private static void add(RunData runData, String prefix, String key,
        long l) {

      String k = prefix + key;

      if (!runData.contains(k)) {
        runData.put(k, 0);
      }

      runData.put(k, runData.getLong(k) + l);
    }

    /**
     * Populate the RunData object with the CVS entry. If a key already exists,
     * add the value to the existing value.
     * @param runData the runData
     * @param prefixes prefixes to use
     * @param readSize the read size
     */
    void populateRunData(RunData runData, List<String> prefixes, int readSize) {

      for (String prefix : prefixes) {

        add(runData, prefix, ".cluster.count", this.readCount);
        add(runData, prefix, ".yield.q30", this.q30BaseCount);
        add(runData, prefix, ".perfect.index.read.count",
            this.perfectIndexReadCount);
        add(runData, prefix, ".one.mismatch.index.read.count",
            this.oneMismatchIndexReadCount);

        add(runData, prefix, ".quality.score.sum",
            this.qualityScoreSum(readSize));

        add(runData, prefix, ".yield", this.yield(readSize));
      }

    }

    /**
     * Constructor.
     * @param parsedLine parsedLie
     */
    Entry(CSVLineParser parsedLine) {

      this.lane = parsedLine.getInt("Lane", -1);
      this.sampleID = parsedLine.get("SampleID");
      this.index = parsedLine.get("Index");
      this.readCount = parsedLine.getInt("# Reads", -1);
      this.perfectIndexReadCount =
          parsedLine.getInt("# Perfect Index Reads", -1);
      this.oneMismatchIndexReadCount =
          parsedLine.getInt("# One Mismatch Index Reads", -1);
      this.q30BaseCount = parsedLine.getLong("# of >= Q30 Bases (PF)", -1);
      this.meanPFQualityScore =
          parsedLine.getDouble("Mean Quality Score (PF)", -1.0);
    }
  }

  @Override
  public void configure(final QC qc, final CollectorConfiguration conf) {

    if (conf == null) {
      return;
    }

    this.bcl2FastqOutputPath = qc.getFastqDir().getPath();
  }

  @Override
  public void collect(final RunData data) throws AozanException {

    if (data == null) {
      return;
    }

    // Demux summary path
    final String demuxSummaryPath =
        this.bcl2FastqOutputPath + "/Reports/Demultiplex_Stats.csv";

    if (!new File(demuxSummaryPath).exists()) {
      throw new AozanException(
          "Demultiplexing Collector: source file not exists "
              + demuxSummaryPath);
    }

    try {
      collect(data, new File(demuxSummaryPath));
    } catch (IOException e) {
      throw new AozanException(e);
    }
  }

  /**
   * Collect values.
   * @param runData the RunData object
   * @param demuxSummaryFile CVS file to parse
   * @throws IOException if an error occurs while reading the CSV file
   */
  private static void collect(final RunData runData,
      final File demuxSummaryFile) throws IOException {

    List<Integer> runReads = runReads(runData);

    Map<String, Integer> indexMap = new HashMap<>();
    int count = 0;

    for (CSVLineParser parsedLine : new CVSParser(
        Files.readAllLines(demuxSummaryFile.toPath()))) {

      Entry e = new Entry(parsedLine);

      if (UNDETERMINED_NAME_KEY.equals(e.sampleID)) {

        // Create entries for undetermined clusters
        addUndeterminedStats(runData, runReads, e);

      } else {

        if (!indexMap.containsKey(e.index)) {
          indexMap.put(e.index, count++);
        }
        int sampleNumber = indexMap.get(e.index);

        // Create entries for sample clusters
        addSampleStats(runData, runReads, sampleNumber, e);
      }
    }
  }

  /**
   * Add statistics in the RunData object for an undetermined entry.
   * @param runData RunData object
   * @param runReads list of reads
   * @param e Parsed CVS entry
   */
  private static void addUndeterminedStats(RunData runData,
      List<Integer> runReads, Entry e) {

    // Add barcodes
    runData.put(
        String.format(PREFIX + ".lane%s.sample.lane%s.barcode", e.lane, e.lane),
        e.index);

    for (int read : runReads) {

      int readSize =
          runData.getInt(String.format("run.info.read%s.cycles", read));

      List<String> prefixes = new ArrayList<>();
      prefixes.add(String.format(PREFIX + ".lane%s.sample.%s.read%d.%s", e.lane,
          e.sampleID, read, "Raw"));
      prefixes.add(String.format(PREFIX + ".lane%s.sample.%s.read%d.%s", e.lane,
          e.sampleID, read, "Pf"));

      prefixes.add(String.format(PREFIX + ".lane%s.sample.lane%s.read%d.%s",
          e.lane, e.lane, read, "Raw"));
      prefixes.add(String.format(PREFIX + ".lane%s.sample.lane%s.read%d.%s",
          e.lane, e.lane, read, "Pf"));

      e.populateRunData(runData, prefixes, readSize);
    }
  }

  /**
   * Add statistics in the RunData object for a sample entry.
   * @param runData RunData object
   * @param runReads list of reads
   * @param e Parsed CVS entry
   */
  private static void addSampleStats(RunData runData, List<Integer> runReads,
      int sampleNumber, Entry e) {

    // Add barcodes
    runData.put(String.format(PREFIX + ".lane%s.sample.%s.barcode%s", e.lane,
        e.sampleID, (sampleNumber == 0 ? "" : sampleNumber)), e.index);

    for (int read : runReads) {

      int readSize =
          runData.getInt(String.format("run.info.read%d.cycles", read));

      List<String> prefixes = new ArrayList<>();
      prefixes.add(String.format(PREFIX + ".lane%s.sample.%s.read%d.%s.%s",
          e.lane, e.sampleID, read, e.index, "Raw"));
      prefixes.add(String.format(PREFIX + ".lane%s.sample.%s.read%d.%s.%s",
          e.lane, e.sampleID, read, e.index, "Pf"));

      prefixes.add(String.format(PREFIX + ".lane%s.sample.%s.read%d.%s", e.lane,
          e.sampleID, read, "Raw"));
      prefixes.add(String.format(PREFIX + ".lane%s.sample.%s.read%d.%s", e.lane,
          e.sampleID, read, "Pf"));

      prefixes.add(String.format(PREFIX + ".lane%s.%s.read%d.%s", e.lane,
          ALL_NAME_KEY, read, "Raw"));
      prefixes.add(String.format(PREFIX + ".lane%s.%s.read%d.%s", e.lane,
          ALL_NAME_KEY, read, "Pf"));

      e.populateRunData(runData, prefixes, readSize);
    }
  }

  /**
   * Get the read number list.
   * @param runData RunData object
   * @return a list with read number
   */
  private static List<Integer> runReads(RunData runData) {

    int max = runData.getInt("run.info.read.count");
    List<Integer> result = new ArrayList<>(max);

    for (int read = 1; read <= max; read++) {
      if (!runData.getBoolean("run.info.read" + read + ".indexed")) {
        result.add(read);
      }
    }

    return result;
  }

}
